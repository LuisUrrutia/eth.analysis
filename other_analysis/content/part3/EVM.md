---
title: "深入理解以太坊虚拟机 EVM"
menuTitle: "EVM"
date: 2020-01-02T14:00:27+08:00
weight: 300005
description: ""
---

以太坊最初由 Vitalik Buterin 在2013年提出。
Vitalik 原本是一名比特币社区的程序员，曾向比特币核心开发人员主张比特币需要一种脚本语言来进行应用程序开发，但当未得到他们的同意，他提议开发一个更通用的脚本语言的新平台。
2013年末，19岁的 Vitalik 给他的好友们发了一份白皮书，建议设计一种新的比特币。
这款新的比特币将基于通用的编程语言，可以用来创建各种各样的应用，比如社交、交易、游戏……

以太坊系统提供的以太坊虚拟机（EVM，Ethereum Virtual Machine）使得基于区块链的各种应用成为可能，让以太坊成为“不可消灭的世界计算机”成为可能。
了解 EVM 对于了解整个以太坊网络的工作方式至关重要，包括智能合约规范以及如何保持可行性和合理性。
EVM 对于以太坊协议必不可少，并且对以太坊系统的共识引擎至关重要。

## EVM 概述

在计算中，虚拟机（VM）是计算机系统的仿真器，通过软件模拟具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统，能提供物理计算机的功能。虚拟机有两类，或者两类的混合。

1. 系统虚拟机：（也称为全虚拟化虚拟机）可代替物理计算机。它提供了运行整个操作系统所需的功能。
2. 程序虚拟机：被设计用来在与平台无关的环境中执行计算机程序。

它们在主机上管理自己的运行时环境和进程，EVM 大致可分为程序虚拟机。
从技术上讲，以太坊是一种点对点的通用全球计算机，甚至可以承担已知的互联网功能。
也正是因这个虚拟机，以太坊才能够在不信任的生态系统内制定智能合约。
能够维护区块链的原则，例如去中心化，透明性和不变性。

EVM 是一个**准图灵完备机**，他为智能合约的执行提供运行时环境，实现以太坊共识模型，从而改变区块链的状态。

> 在计算中，如果一台机器可以用图灵机器解决所有的可计算问题，则称该机器是图灵完备性（Turing Completeness）的。

EVM 之所以称为准图灵完备机，是因为它与基于冯·诺依曼架构的机器不同，该机器的计算受内存和时间限制，
而EVM上的计算受称为 [Gas]({{<ref "gas.md" >}})（燃料） 参数限制。
Gas 是在以太坊计算引擎上执行操作的单位开销。在EVM上执行程序（智能合约）之前，先估算程序中每个操作的 Gas 开销，然后在执行程序中的每个操作时付费。在 EVM 中的程序靠 Gas 燃料作为动力来驱动。
这限制了每个程序的EVM执行的操作数量，因为程序可能会用光Gas。


以太坊的共识执行模型指定了在给定的一系列字节码指令的情况下如何修改以太坊世界状态(World State)。
这些字节码指令由 EVM 编译器根据智能合约和环境信息编译。
EVM 的作用是通过为智能合约提供运行时环境来实现此执行模型，该智能合约已被 EVM 编译器编译为要执行的字节码，
EVM 管理合约发起交易的执行，然后将区块链转换为新状态。

## EVM 架构

EVM是一个简单的基于堆栈体系结构的虚拟机，具有平台无关性。
在 EVM 上的计算是使用基于堆栈的字节码语言完成的，该语言类似于JAVA中间语言。

![以太坊技术与实现-图-EVM架构](https://img.learnblockchain.cn/book_geth/2020-1-11-10-43-59.png!de?width=500px)

堆栈的功能是存储字节码指令（操作码）的间歇执行结果。
EVM堆栈上每数据项大小为 256-bits（32字节），如果数据项的大小不超过256位，则用前导零填充。
堆栈是先进后出（FILO），最大大小为 1024，初始大小为 0。

![以太坊技术与实现-图-EVM堆栈与内存模型](https://img.learnblockchain.cn/book_geth/2020-1-11-10-47-46.png!de?width=600px)

EVM 的内存模型是简单的基于字寻址的字节数组，每项数据都分配有自己的内存地址（数组偏移量和大小）。
内存初始大小为 0，根据需要增长。
不允许越界的内存访问，改变内存大小需要付出高昂的燃料。

EVM的存储模型，与易失性存储器不同，该存储是可持久化的，是系统状态的一部分。
包含智能合约代码等基本信息和合约中存储内容，
读取或修改存储中的数据也需要付出高昂的燃料。


## EVM 模型

EVM中由多个子模块的相互配合类构建智能合约执行的沙盒环境。

![以太坊技术与实现-图-2020-1-18-15-51-55.png](https://img.learnblockchain.cn/book_geth/2020-1-18-15-51-55.png!de?width=600px)

上图是以太坊虚拟机模型，合约字节码中指定了 EVM 要执行怎样的指令运算。
PC 是程序计算器，用于指明代码的执行位置。
每次读到的一个指令，都有对应的运算逻辑。如果不存在则说明指令错误，合约执行终止。
在运算时将从堆栈、内存、账户StateDB中读写数据。

EVM 的启动是由外部交易或者合约内部触发执行。

![以太坊技术与实现-图-2020-1-18-16-18-41.png](https://img.learnblockchain.cn/book_geth/2020-1-18-16-18-41.png!de?width=600px)

在上图中，EVM 只能被外部已签名的合法交易携带入参和指定需要调用的合约来启动，
在启动时将携带输入数据，在 EVM 运行时，运行中的智能合约可以调用其他智能合约，并可以记录事件日志信息。
EVM 执行完毕，可获得返回结果。

## EVM 安全性

EVM 在保护以太坊区块链方面发挥着重要作用。
EVM是面向安全的虚拟机，旨在允许在全球计算机网络上执行不受信任的代码。
EVM施加了以下一组限制来保护系统：

1. 执行程序过程中每个计算步骤都必须预先付费，从而防止拒绝服务（DoS）攻击。如果预先支付了计算步骤，则打算在EVM上无限执行的任何恶意程序最终都会在某个时刻耗尽资源，从而确保该恶意程序的执行不会拒绝其他程序使用EVM。
2. 程序只能通过传输单个任意长度的字节数组来进行交互。他们无法访问彼此的状态。
3. 程序执行是沙盒操作；一个EVM程序可以访问和修改其自身的内部状态，并且可以触发其他EVM程序的执行，但除此之外别无其他。
4. 程序执行是完全确定性的，并为以相同状态开始的执行都而产生相同的状态转换。

这些限制有助于塑造以太坊状态转换机的设计决策。

## EVM 执行指令

EVM 要执行怎样的计算，由通过智能合约的字节码决定。字节码由一系列字节码指令和指令参数组成。
操作指令，主要在以太坊黄皮书中定义（这里分享一份[在线 Excel 版的以太坊指令集](https://www.kdocs.cn/l/sUdDgSHE4)）。

下面是一个简单的字节码 `0x6002600802`，用 [evm命令程序](https://github.com/ethereum/go-ethereum/tree/master/cmd/evm) 解析成可读指令。

```bash
echo "6002600802" > code.bin
evm disasm code.bin
rm code.bin
```

可得到如下解析结果。

```html
6002600802
00000: PUSH1 0x02
00002: PUSH1 0x08
00004: MUL
```

这段字节码是推入数字 2 和 8，再两数相乘。
我们可以执行命令 `evm --debug --code 6002600802 run` 得到看到EVM执行过程信息。

```html
0x0
#### TRACE ####
PUSH1           pc=00000000 gas=10000000000 cost=0

PUSH1           pc=00000002 gas=9999999997 cost=0
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000002

MUL             pc=00000004 gas=9999999994 cost=0
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000008
00000001  0000000000000000000000000000000000000000000000000000000000000002

STOP            pc=00000005 gas=9999999989 cost=0
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000010

#### LOGS ####
```

参数 `--debug` 可跟踪打印每一步指令执行的堆栈变化情况。
上面信息中，先推送一个 uint8 的数字 2 到堆栈，再推送 uint8 数字 8。
然后执行相乘指令，将取出栈顶的数字 2 和 8，得到相乘结果 16，再推入栈顶。
可是代码执行结果确实 0，并非 0x10。
这是因为代码在执行完相乘指令后，并没有后续指令执行。
我们需要将数字`0x10`存储到内存中后，再执行`return`指令来获得结果。

根据指令参数要求，可以把上面字节码修改为`60026008026000526001601ff3`。

执行 disasm 命令可以如下指令信息：

```bash
echo "60026008026000526001601ff3" > code.bin
evm disasm code.bin

// output
//60026008026000526001601ff3
//00000: PUSH1 0x02
//00002: PUSH1 0x08
//00004: MUL
//00005: PUSH1 0x00
//00007: MSTORE
//00008: PUSH1 0x01
//0000a: PUSH1 0x1f
//0000c: RETURN
```

这里将结果`0x10`存储到内存的 0 位置上。
因为 EVM 是进行高端字节处理，`0x10` 推入栈顶时已经被当做 32 位字节处理。
此时，内存的 0 位置中存储的字节是 `00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 10`。
因此，我们只需要从内存的第 31 位置开始获取 1 个字节即可得到返回计算结果。

继续运行代码  `evm --debug --code 60026008026000526001601ff3 run`，
可以看到 0x10 有存入到内存中，然后被返回。

```html
0x10
#### TRACE ####
PUSH1           pc=00000000 gas=10000000000 cost=0

PUSH1           pc=00000002 gas=9999999997 cost=0
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000002

MUL             pc=00000004 gas=9999999994 cost=0
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000008
00000001  0000000000000000000000000000000000000000000000000000000000000002

PUSH1           pc=00000005 gas=9999999989 cost=0
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000010

MSTORE          pc=00000007 gas=9999999986 cost=6
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000000
00000001  0000000000000000000000000000000000000000000000000000000000000010
Memory:
00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

PUSH1           pc=00000008 gas=9999999980 cost=6
Memory:
00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 10  |................|

PUSH1           pc=00000010 gas=9999999977 cost=6
Stack:
00000000  0000000000000000000000000000000000000000000000000000000000000001
Memory:
00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 10  |................|

RETURN          pc=00000012 gas=9999999974 cost=0
Stack:
00000000  000000000000000000000000000000000000000000000000000000000000001f
00000001  0000000000000000000000000000000000000000000000000000000000000001
Memory:
00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 10  |................|

#### LOGS ####
```